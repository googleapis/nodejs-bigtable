// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import {before, describe, it} from 'mocha';
import {Bigtable} from '../src';
import * as assert from 'assert';

import {GoogleError, grpc, ServiceError} from 'google-gax';
import {MockServer} from '../src/util/mock-servers/mock-server';
import {BigtableClientMockService} from '../src/util/mock-servers/service-implementations/bigtable-client-mock-service';
import {MockService} from '../src/util/mock-servers/mock-service';

function isServiceError(error: any): error is ServiceError {
  return (
    error.code !== undefined &&
    error.details !== undefined &&
    error.metadata !== undefined
  );
}

describe('Bigtable/Errors', () => {
  let server: MockServer;
  let bigtable: Bigtable;
  let table: any;

  before(done => {
    server = new MockServer(() => {
      bigtable = new Bigtable({
        apiEndpoint: `localhost:${server.port}`,
      });
      table = bigtable.instance('fake-instance').table('fake-table');
      done();
    });
  });

  describe('with the bigtable data client', () => {
    let service: MockService;
    before(async () => {
      service = new BigtableClientMockService(server);
    });

    describe('sends errors through a streaming request', () => {
      const errorDetails =
        'Table not found: projects/my-project/instances/my-instance/tables/my-table';
      function emitErrorWithCode(stream: any, code: number) {
        const metadata = new grpc.Metadata();
        metadata.set(
          'grpc-server-stats-bin',
          Buffer.from([0, 0, 116, 73, 159, 3, 0, 0, 0, 0])
        );
        stream.emit('error', {
          code: code,
          details: errorDetails,
          metadata,
        });
      }
      const emitTableNotExistsError = (stream: any) => {
        emitErrorWithCode(stream, 5);
      };
      const emitDeadlineExceededError = (stream: any) => {
        emitErrorWithCode(stream, grpc.status.DEADLINE_EXCEEDED);
      };
      function checkError(
        err: any,
        expectedCode: number,
        expectedMessage: string
      ) {
        if (isServiceError(err)) {
          const {code, message, details} = err;
          assert.strictEqual(details, errorDetails);
          assert.strictEqual(code, expectedCode);
          assert.strictEqual(message, expectedMessage);
        } else {
          assert.fail(
            'Errors checked using this function should all be GoogleErrors'
          );
        }
      }
      function checkTableNotExistError(err: any) {
        checkError(err, 5, `5 NOT_FOUND: ${errorDetails}`);
      }
      function checkDeadlineExceededError(err: any) {
        checkError(
          err,
          grpc.status.DEADLINE_EXCEEDED,
          `4 DEADLINE_EXCEEDED: ${errorDetails}`
        );
      }
      describe('with ReadRows service', () => {
        before(async () => {
          service.setService({
            ReadRows: emitTableNotExistsError,
          });
        });
        it('should produce human readable error when passing through gax', done => {
          const readStream = table.createReadStream({});
          readStream.on('error', (err: GoogleError) => {
            checkTableNotExistError(err);
            done();
          });
        });
      });
      describe('with ReadRows service and a deadline exceeded error', () => {
        before(async () => {
          service.setService({
            ReadRows: emitDeadlineExceededError,
          });
        });
        it('should produce human readable error when passing through gax', done => {
          const readStream = table.createReadStream({});
          readStream.on('error', (err: GoogleError) => {
            checkDeadlineExceededError(err);
            done();
          });
        });
      });
      describe('with mutateRows service through insert', () => {
        before(async () => {
          service.setService({
            mutateRows: emitTableNotExistsError,
          });
        });
        it('should produce human readable error when passing through gax', async () => {
          const timestamp = new Date();
          const rowsToInsert = [
            {
              key: 'r2',
              data: {
                cf1: {
                  c1: {
                    value: 'test-value2',
                    labels: [],
                    timestamp,
                  },
                },
              },
            },
          ];
          try {
            await table.insert(rowsToInsert);
          } catch (err) {
            checkTableNotExistError(err);
            return;
          }
          assert.fail('An error should have been thrown by the stream');
        });
      });
      describe('with sampleRowKeys', () => {
        before(async () => {
          service.setService({
            sampleRowKeys: emitTableNotExistsError,
          });
        });
        it('should produce human readable error when passing through gax', async () => {
          try {
            await table.sampleRowKeys({});
          } catch (err) {
            checkTableNotExistError(err);
            return;
          }
          assert.fail('An error should have been thrown by the stream');
        });
      });
    });
  });
  after(async () => {
    server.shutdown(() => {});
  });
});
